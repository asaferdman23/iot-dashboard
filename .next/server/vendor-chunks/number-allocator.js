/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/number-allocator";
exports.ids = ["vendor-chunks/number-allocator"];
exports.modules = {

/***/ "(ssr)/./node_modules/number-allocator/index.js":
/*!************************************************!*\
  !*** ./node_modules/number-allocator/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\nconst NumberAllocator = __webpack_require__(/*! ./lib/number-allocator.js */ \"(ssr)/./node_modules/number-allocator/lib/number-allocator.js\")\n\nmodule.exports.NumberAllocator = NumberAllocator\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWFsbG9jYXRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsZ0dBQTJCOztBQUUzRCw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pb3RfY2hlY2svLi9ub2RlX21vZHVsZXMvbnVtYmVyLWFsbG9jYXRvci9pbmRleC5qcz8wMjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBUYWthdG9zaGkgS29uZG8gMjAyMVxuLy9cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuXG5jb25zdCBOdW1iZXJBbGxvY2F0b3IgPSByZXF1aXJlKCcuL2xpYi9udW1iZXItYWxsb2NhdG9yLmpzJylcblxubW9kdWxlLmV4cG9ydHMuTnVtYmVyQWxsb2NhdG9yID0gTnVtYmVyQWxsb2NhdG9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-allocator/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/number-allocator/lib/number-allocator.js":
/*!***************************************************************!*\
  !*** ./node_modules/number-allocator/lib/number-allocator.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n\n\nconst SortedSet = (__webpack_require__(/*! js-sdsl */ \"(ssr)/./node_modules/js-sdsl/dist/cjs/index.js\").OrderedSet)\nconst debugTrace = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('number-allocator:trace')\nconst debugError = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.begin()\n  const low = it.pointer.low\n  const high = it.pointer.high\n  const num = low\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low\n    const high = it.pointer.high\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (low > num) return false\n\n    // |x----|\n    if (low === num) {\n      // x|----|\n      this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (high === num) {\n      // |----|x\n      this.ss.updateKeyByIterator(it, new Interval(low, high - 1))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |--x--|\n    // x|--|\n    this.ss.updateKeyByIterator(it, new Interval(num + 1, high))\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.upperBound(key)\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    it.pre()\n    const low = it.pointer.high\n    const high = it.pointer.high\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.updateKeyByIterator(it, new Interval(low, num))\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const high = it.pointer.high\n        this.ss.updateKeyByIterator(it, new Interval(num, high))\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low\n      const rHigh = it.pointer.high\n      it.pre()\n      const lLow = it.pointer.low\n      const lHigh = it.pointer.high\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it)\n          this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh))\n        } else {\n          // Concat to left\n          this.ss.updateKeyByIterator(it, new Interval(lLow, num))\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next())\n          this.ss.insert(new Interval(num, rHigh))\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWFsbG9jYXRvci9saWIvbnVtYmVyLWFsbG9jYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosa0JBQWtCLGlHQUE2QjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBTztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pb3RfY2hlY2svLi9ub2RlX21vZHVsZXMvbnVtYmVyLWFsbG9jYXRvci9saWIvbnVtYmVyLWFsbG9jYXRvci5qcz9hMDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBUYWthdG9zaGkgS29uZG8gMjAyMVxuLy9cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgU29ydGVkU2V0ID0gcmVxdWlyZSgnanMtc2RzbCcpLk9yZGVyZWRTZXRcbmNvbnN0IGRlYnVnVHJhY2UgPSByZXF1aXJlKCdkZWJ1ZycpKCdudW1iZXItYWxsb2NhdG9yOnRyYWNlJylcbmNvbnN0IGRlYnVnRXJyb3IgPSByZXF1aXJlKCdkZWJ1ZycpKCdudW1iZXItYWxsb2NhdG9yOmVycm9yJylcbi8qKlxuICogSW50ZXJ2YWwgY29uc3RydWN0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IGxvdyAgLSBUaGUgbG93ZXN0IHZhbHVlIG9mIHRoZSBpbnRlcnZhbFxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggLSBUaGUgaGlnaGVzdCB2YWx1ZSBvZiB0aGUgaW50ZXJ2YWxcbiAqL1xuZnVuY3Rpb24gSW50ZXJ2YWwgKGxvdywgaGlnaCkge1xuICB0aGlzLmxvdyA9IGxvd1xuICB0aGlzLmhpZ2ggPSBoaWdoXG59XG5cbkludGVydmFsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMubG93ID09PSBvdGhlci5sb3cgJiYgdGhpcy5oaWdoID09PSBvdGhlci5oaWdoXG59XG5cbkludGVydmFsLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmICh0aGlzLmxvdyA8IG90aGVyLmxvdyAmJiB0aGlzLmhpZ2ggPCBvdGhlci5sb3cpIHJldHVybiAtMVxuICBpZiAob3RoZXIubG93IDwgdGhpcy5sb3cgJiYgb3RoZXIuaGlnaCA8IHRoaXMubG93KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vKipcbiAqIE51bWJlckFsbG9jYXRvciBjb25zdHJ1Y3Rvci5cbiAqIFRoZSBhbGwgbnVtYmVycyBhcmUgc2V0IHRvIHZhY2FudCBzdGF0dXMuXG4gKiBUaW1lIENvbXBsZXhpdHkgTygxKVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gbWluICAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhbGxvY2F0YWJsZS4gVGhlIG51bWJlciBtdXN0IGJlIGludGVnZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4aCAtIFRoZSBtaW5pbXVtIG51bWJlciBvZiBhbGxvY2F0YWJsZS4gVGhlIG51bWJlciBtdXN0IGJlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIE51bWJlckFsbG9jYXRvciAobWluLCBtYXgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE51bWJlckFsbG9jYXRvcikpIHtcbiAgICByZXR1cm4gbmV3IE51bWJlckFsbG9jYXRvcihtaW4sIG1heClcbiAgfVxuXG4gIHRoaXMubWluID0gbWluXG4gIHRoaXMubWF4ID0gbWF4XG5cbiAgdGhpcy5zcyA9IG5ldyBTb3J0ZWRTZXQoXG4gICAgW10sXG4gICAgKGxocywgcmhzKSA9PiB7XG4gICAgICByZXR1cm4gbGhzLmNvbXBhcmUocmhzKVxuICAgIH1cbiAgKVxuICBkZWJ1Z1RyYWNlKCdDcmVhdGUnKVxuICB0aGlzLmNsZWFyKClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IHZhY2FudCBudW1iZXIuIFRoZSBzdGF0dXMgb2YgdGhlIG51bWJlciBpcyBub3QgdXBkYXRlZC5cbiAqIFRpbWUgQ29tcGxleGl0eSBPKDEpXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIGZpcnN0IHZhY2FudCBudW1iZXIuIElmIGFsbCBudW1iZXJzIGFyZSBvY2N1cGllZCwgcmV0dXJuIG51bGwuXG4gKiAgICAgICAgICAgICAgICAgICAgV2hlbiBhbGxvYygpIGlzIGNhbGxlZCB0aGVuIHRoZSBzYW1lIHZhbHVlIHdpbGwgYmUgYWxsb2NhdGVkLlxuICovXG5OdW1iZXJBbGxvY2F0b3IucHJvdG90eXBlLmZpcnN0VmFjYW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zcy5zaXplKCkgPT09IDApIHJldHVybiBudWxsXG4gIHJldHVybiB0aGlzLnNzLmZyb250KCkubG93XG59XG5cbi8qKlxuICogQWxsb2NhdGUgdGhlIGZpcnN0IHZhY2FudCBudW1iZXIuIFRoZSBudW1iZXIgYmVjb21lIG9jY3VwaWVkIHN0YXR1cy5cbiAqIFRpbWUgQ29tcGxleGl0eSBPKDEpXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIGZpcnN0IHZhY2FudCBudW1iZXIuIElmIGFsbCBudW1iZXJzIGFyZSBvY2N1cGllZCwgcmV0dXJuIG51bGwuXG4gKi9cbk51bWJlckFsbG9jYXRvci5wcm90b3R5cGUuYWxsb2MgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNzLnNpemUoKSA9PT0gMCkge1xuICAgIGRlYnVnVHJhY2UoJ2FsbG9jKCk6ZW1wdHknKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgaXQgPSB0aGlzLnNzLmJlZ2luKClcbiAgY29uc3QgbG93ID0gaXQucG9pbnRlci5sb3dcbiAgY29uc3QgaGlnaCA9IGl0LnBvaW50ZXIuaGlnaFxuICBjb25zdCBudW0gPSBsb3dcbiAgaWYgKG51bSArIDEgPD0gaGlnaCkge1xuICAgIC8vIHh8LS0tLXxcbiAgICB0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IoaXQsIG5ldyBJbnRlcnZhbChsb3cgKyAxLCBoaWdoKSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNzLmVyYXNlRWxlbWVudEJ5UG9zKDApXG4gIH1cbiAgZGVidWdUcmFjZSgnYWxsb2MoKTonICsgbnVtKVxuICByZXR1cm4gbnVtXG59XG5cbi8qKlxuICogVXNlIHRoZSBudW1iZXIuIFRoZSBudW1iZXIgYmVjb21lIG9jY3VwaWVkIHN0YXR1cy5cbiAqIElmIHRoZSBudW1iZXIgaGFzIGFscmVhZHkgYmVlbiBvY2N1cGllZCwgdGhlbiByZXR1cm4gZmFsc2UuXG4gKiBUaW1lIENvbXBsZXhpdHkgTyhsb2dOKSA6IE4gaXMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgKG5vdCBudW1iZXJzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gcmVxdWVzdCB1c2UuXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIElmIGBudW1gIHdhcyBub3Qgb2NjdXBpZWQsIHRoZW4gcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gKi9cbk51bWJlckFsbG9jYXRvci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKG51bSkge1xuICBjb25zdCBrZXkgPSBuZXcgSW50ZXJ2YWwobnVtLCBudW0pXG4gIGNvbnN0IGl0ID0gdGhpcy5zcy5sb3dlckJvdW5kKGtleSlcbiAgaWYgKCFpdC5lcXVhbHModGhpcy5zcy5lbmQoKSkpIHtcbiAgICBjb25zdCBsb3cgPSBpdC5wb2ludGVyLmxvd1xuICAgIGNvbnN0IGhpZ2ggPSBpdC5wb2ludGVyLmhpZ2hcbiAgICBpZiAoaXQucG9pbnRlci5lcXVhbHMoa2V5KSkge1xuICAgICAgLy8gfHh8XG4gICAgICB0aGlzLnNzLmVyYXNlRWxlbWVudEJ5SXRlcmF0b3IoaXQpXG4gICAgICBkZWJ1Z1RyYWNlKCd1c2UoKTonICsgbnVtKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyB4IHwtLS0tLXxcbiAgICBpZiAobG93ID4gbnVtKSByZXR1cm4gZmFsc2VcblxuICAgIC8vIHx4LS0tLXxcbiAgICBpZiAobG93ID09PSBudW0pIHtcbiAgICAgIC8vIHh8LS0tLXxcbiAgICAgIHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihpdCwgbmV3IEludGVydmFsKGxvdyArIDEsIGhpZ2gpKVxuICAgICAgZGVidWdUcmFjZSgndXNlKCk6JyArIG51bSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gfC0tLS14fFxuICAgIGlmIChoaWdoID09PSBudW0pIHtcbiAgICAgIC8vIHwtLS0tfHhcbiAgICAgIHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihpdCwgbmV3IEludGVydmFsKGxvdywgaGlnaCAtIDEpKVxuICAgICAgZGVidWdUcmFjZSgndXNlKCk6JyArIG51bSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gfC0teC0tfFxuICAgIC8vIHh8LS18XG4gICAgdGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKGl0LCBuZXcgSW50ZXJ2YWwobnVtICsgMSwgaGlnaCkpXG4gICAgLy8gfC0tfHh8LS18XG4gICAgdGhpcy5zcy5pbnNlcnQobmV3IEludGVydmFsKGxvdywgbnVtIC0gMSkpXG4gICAgZGVidWdUcmFjZSgndXNlKCk6JyArIG51bSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZGVidWdUcmFjZSgndXNlKCk6ZmFpbGVkJylcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZSB0aGUgbnVtYmVyLiBUaGUgbnVtYmVyIGJlY29tZSB2YWNhbnQgc3RhdHVzLlxuICogVGltZSBDb21wbGV4aXR5IE8obG9nTikgOiBOIGlzIHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzIChub3QgbnVtYmVycylcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIGRlYWxsb2NhdGUuIFRoZSBudW1iZXIgbXVzdCBiZSBvY2N1cGllZCBzdGF0dXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBudW1iZXIgbXVzdCBiZSBhbGxvY2F0ZWQgYnkgYWxsb2MoKSBvciBvY2N1cGllZCBiZSB1c2UoKS5cbiAqL1xuTnVtYmVyQWxsb2NhdG9yLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24gKG51bSkge1xuICBpZiAobnVtIDwgdGhpcy5taW4gfHwgbnVtID4gdGhpcy5tYXgpIHtcbiAgICBkZWJ1Z0Vycm9yKCdmcmVlKCk6JyArIG51bSArICcgaXMgb3V0IG9mIHJhbmdlJylcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBrZXkgPSBuZXcgSW50ZXJ2YWwobnVtLCBudW0pXG4gIGNvbnN0IGl0ID0gdGhpcy5zcy51cHBlckJvdW5kKGtleSlcbiAgaWYgKGl0LmVxdWFscyh0aGlzLnNzLmVuZCgpKSkge1xuICAgIC8vIC4uLi52XG4gICAgaWYgKGl0LmVxdWFscyh0aGlzLnNzLmJlZ2luKCkpKSB7XG4gICAgICAvLyBJbnNlcnQgbmV3IGludGVydmFsXG4gICAgICB0aGlzLnNzLmluc2VydChrZXkpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaXQucHJlKClcbiAgICBjb25zdCBsb3cgPSBpdC5wb2ludGVyLmhpZ2hcbiAgICBjb25zdCBoaWdoID0gaXQucG9pbnRlci5oaWdoXG4gICAgaWYgKGhpZ2ggKyAxID09PSBudW0pIHtcbiAgICAgIC8vIENvbmNhdCB0byBsZWZ0XG4gICAgICB0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IoaXQsIG5ldyBJbnRlcnZhbChsb3csIG51bSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydCBuZXcgaW50ZXJ2YWxcbiAgICAgIHRoaXMuc3MuaW5zZXJ0KGtleSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGl0LmVxdWFscyh0aGlzLnNzLmJlZ2luKCkpKSB7XG4gICAgICAvLyB2Li4uLlxuICAgICAgaWYgKG51bSArIDEgPT09IGl0LnBvaW50ZXIubG93KSB7XG4gICAgICAgIC8vIENvbmNhdCB0byByaWdodFxuICAgICAgICBjb25zdCBoaWdoID0gaXQucG9pbnRlci5oaWdoXG4gICAgICAgIHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihpdCwgbmV3IEludGVydmFsKG51bSwgaGlnaCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbnNlcnQgbmV3IGludGVydmFsXG4gICAgICAgIHRoaXMuc3MuaW5zZXJ0KGtleSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLi52Li5cbiAgICAgIGNvbnN0IHJMb3cgPSBpdC5wb2ludGVyLmxvd1xuICAgICAgY29uc3QgckhpZ2ggPSBpdC5wb2ludGVyLmhpZ2hcbiAgICAgIGl0LnByZSgpXG4gICAgICBjb25zdCBsTG93ID0gaXQucG9pbnRlci5sb3dcbiAgICAgIGNvbnN0IGxIaWdoID0gaXQucG9pbnRlci5oaWdoXG4gICAgICBpZiAobEhpZ2ggKyAxID09PSBudW0pIHtcbiAgICAgICAgaWYgKG51bSArIDEgPT09IHJMb3cpIHtcbiAgICAgICAgICAvLyBDb25jYXQgdG8gbGVmdCBhbmQgcmlnaHRcbiAgICAgICAgICB0aGlzLnNzLmVyYXNlRWxlbWVudEJ5SXRlcmF0b3IoaXQpXG4gICAgICAgICAgdGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKGl0LCBuZXcgSW50ZXJ2YWwobExvdywgckhpZ2gpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENvbmNhdCB0byBsZWZ0XG4gICAgICAgICAgdGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKGl0LCBuZXcgSW50ZXJ2YWwobExvdywgbnVtKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG51bSArIDEgPT09IHJMb3cpIHtcbiAgICAgICAgICAvLyBDb25jYXQgdG8gcmlnaHRcbiAgICAgICAgICB0aGlzLnNzLmVyYXNlRWxlbWVudEJ5SXRlcmF0b3IoaXQubmV4dCgpKVxuICAgICAgICAgIHRoaXMuc3MuaW5zZXJ0KG5ldyBJbnRlcnZhbChudW0sIHJIaWdoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbnNlcnQgbmV3IGludGVydmFsXG4gICAgICAgICAgdGhpcy5zcy5pbnNlcnQoa2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlYnVnVHJhY2UoJ2ZyZWUoKTonICsgbnVtKVxufVxuXG4vKipcbiAqIENsZWFyIGFsbCBvY2N1cGllZCBudW1iZXJzLlxuICogVGhlIGFsbCBudW1iZXJzIGFyZSBzZXQgdG8gdmFjYW50IHN0YXR1cy5cbiAqIFRpbWUgQ29tcGxleGl0eSBPKDEpXG4gKi9cbk51bWJlckFsbG9jYXRvci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnVHJhY2UoJ2NsZWFyKCknKVxuICB0aGlzLnNzLmNsZWFyKClcbiAgdGhpcy5zcy5pbnNlcnQobmV3IEludGVydmFsKHRoaXMubWluLCB0aGlzLm1heCkpXG59XG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzLiBJbnRlcnZhbCBpcyBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgdGhpcyBsaWJyYXJ5LlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgZGVidWdnaW5nLlxuICogVGltZSBDb21wbGV4aXR5IE8oMSlcbiAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgbnVtYmVyIG9mIGludGVydmFscy5cbiAqL1xuTnVtYmVyQWxsb2NhdG9yLnByb3RvdHlwZS5pbnRlcnZhbENvdW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zcy5zaXplKClcbn1cblxuLyoqXG4gKiBEdW1wIHRoZSBpbnRlcm5hbCBzdHJ1Y3RvciBvZiB0aGUgbGlicmFyeS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZy5cbiAqIFRpbWUgQ29tcGxleGl0eSBPKE4pIDogTiBpcyB0aGUgbnVtYmVyIG9mIGludGVydmFscyAobm90IG51bWJlcnMpXG4gKi9cbk51bWJlckFsbG9jYXRvci5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS5sb2coJ2xlbmd0aDonICsgdGhpcy5zcy5zaXplKCkpXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnNzKSB7XG4gICAgY29uc29sZS5sb2coZWxlbWVudClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlckFsbG9jYXRvclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-allocator/lib/number-allocator.js\n");

/***/ })

};
;